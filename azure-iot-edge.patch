diff --git a/edgelet/hsm-sys/azure-iot-hsm-c/src/hsm_client_tpm_device.c b/edgelet/hsm-sys/azure-iot-hsm-c/src/hsm_client_tpm_device.c
index 1f233d83..44fdff86 100644
--- a/edgelet/hsm-sys/azure-iot-hsm-c/src/hsm_client_tpm_device.c
+++ b/edgelet/hsm-sys/azure-iot-hsm-c/src/hsm_client_tpm_device.c
@@ -24,11 +24,17 @@
 #define HMAC_LENGTH                 32
 #define TPM_DATA_LENGTH             1024
 
+#if 0
 static TPM2B_AUTH      NullAuth = { .t = {0,  {0}} };
+#endif 
 static TSS_SESSION     NullPwSession;
+#if 0
 static const UINT32 TPM_20_SRK_HANDLE = HR_PERSISTENT | 0x00000001;
 static const UINT32 TPM_20_EK_HANDLE = HR_PERSISTENT | 0x00010001;
 static const UINT32 DPS_ID_KEY_HANDLE = HR_PERSISTENT | 0x00000100;
+#endif 
+#define SRK_PUB_FILE "/home/ubuntu/hsm/srk.pub"
+#define EK_PUB_FILE "/home/ubuntu/hsm/ek.pub"
 
 typedef struct HSM_CLIENT_INFO_TAG
 {
@@ -41,6 +47,8 @@ typedef struct HSM_CLIENT_INFO_TAG
     TPM2B_PRIVATE id_key_priv;
 } HSM_CLIENT_INFO;
 
+
+#if 0
 static TPMS_RSA_PARMS  RsaStorageParams = {
     { TPM_ALG_AES, {128}, {TPM_ALG_CFB} },              // TPMT_SYM_DEF_OBJECT  symmetric
     { TPM_ALG_NULL,  {.anySig = {ALG_ERROR_VALUE} }},   // TPMT_RSA_SCHEME      scheme
@@ -86,7 +94,7 @@ static TPM2B_PUBLIC* GetSrkTemplate()
     SrkTemplate.publicArea.parameters.rsaDetail = RsaStorageParams;
     return &SrkTemplate;
 }
-
+#endif 
 #define DPS_UNMARSHAL(Type, pValue) \
 {                                                                       \
     TPM_RC rc = Type##_Unmarshal(pValue, &curr_pos, (INT32*)&act_size);         \
@@ -96,6 +104,11 @@ static TPM2B_PUBLIC* GetSrkTemplate()
     }                                                                   \
 }
 
+#define DPS_MARSHAL(Type, pValue, pBuffer, size) \
+{                                                                       \
+    buflen = Type##_Marshal(pValue, &pBuffer, (INT32*)&size);      \
+}
+
 #define DPS_UNMARSHAL_FLAGGED(Type, pValue) \
 {                                                                       \
     TPM_RC rc = Type##_Unmarshal(pValue, &curr_pos, (INT32*)&act_size, TRUE);   \
@@ -120,6 +133,7 @@ static TPM2B_PUBLIC* GetSrkTemplate()
         curr_pos += arrSize;                         \
     }
 
+#if 0
 static int create_tpm_session
 (
     HSM_CLIENT_INFO* sec_info,
@@ -144,148 +158,310 @@ static int create_tpm_session
     }
     return result;
 }
+#endif 
 
-static int insert_key_in_tpm
-(
-    HSM_CLIENT_INFO* sec_info,
-    const unsigned char* key,
-    size_t key_len
-)
+
+static int
+write_buf_to_file (const char *buf, int buflen, const char *filename)
 {
-    int result;
-    TSS_SESSION ek_sess;
-    memset(&ek_sess, 0, sizeof(TSS_SESSION));
-    if (create_tpm_session(sec_info, &ek_sess) != 0)
-    {
-        LOG_ERROR("Failure: Starting EK policy session");
-        result = __FAILURE__;
-    }
-    else
-    {
-        TPMT_SYM_DEF_OBJECT Aes128SymDef = { TPM_ALG_AES, {128}, {TPM_ALG_CFB} };
-        TPM2B_ID_OBJECT enc_key_blob;
-        TPM2B_ENCRYPTED_SECRET tpm_enc_secret;
-        TPM2B_PRIVATE id_key_dup_blob;
-        TPM2B_ENCRYPTED_SECRET encrypt_wrap_key;
-        TPM2B_PUBLIC id_key_Public;
-        UINT16 enc_data_size = 0;
-        TPM2B_DIGEST inner_wrap_key = { .t = {0, {0}} };
-        TPM2B_PRIVATE id_key_priv;
-        TPM_HANDLE load_id_key = TPM_ALG_NULL;
-
-        uint8_t* curr_pos = (uint8_t*)key;
-        uint32_t act_size = (int32_t)key_len;
-        memset(&id_key_Public, 0, sizeof(TPM2B_PUBLIC));
-        id_key_Public.size = 0;
-        id_key_Public.publicArea.type = TPM_ALG_NULL;
-        DPS_UNMARSHAL(TPM2B_ID_OBJECT, &enc_key_blob);
-        DPS_UNMARSHAL(TPM2B_ENCRYPTED_SECRET, &tpm_enc_secret);
-        DPS_UNMARSHAL(TPM2B_PRIVATE, &id_key_dup_blob);
-        DPS_UNMARSHAL(TPM2B_ENCRYPTED_SECRET, &encrypt_wrap_key);
-        DPS_UNMARSHAL_FLAGGED(TPM2B_PUBLIC, &id_key_Public);
-
-        // The given TPM may support larger TPM2B_MAX_BUFFER than this API headers define.
-        // So instead of unmarshaling data in a standalone data structure just reuse the
-        // original activation buffer (after updating byte order of the UINT16 counter)
-        DPS_UNMARSHAL(UINT16, &enc_data_size);
-
-        if (TPM2_ActivateCredential(&sec_info->tpm_device, &NullPwSession, &ek_sess, TPM_20_SRK_HANDLE, TPM_20_EK_HANDLE,
-            &enc_key_blob, &tpm_enc_secret, &inner_wrap_key) != TPM_RC_SUCCESS)
-        {
-            LOG_ERROR("Failure: TPM2_ActivateCredential");
-            result = __FAILURE__;
-        }
-        else if (TPM2_Import(&sec_info->tpm_device, &NullPwSession, TPM_20_SRK_HANDLE, (TPM2B_DATA*)&inner_wrap_key, &id_key_Public, &id_key_dup_blob, &encrypt_wrap_key, &Aes128SymDef, &id_key_priv) != TPM_RC_SUCCESS)
-        {
-            LOG_ERROR("Failure: importing dps Id key");
-            result = __FAILURE__;
-        }
-        else
-        {
-            TPM2B_SENSITIVE_CREATE sen_create = { 0 };
-            TPM2B_PUBLIC sym_pub;
-            TPM2B_PRIVATE sym_priv;
+	FILE *fp = fopen(filename, "wb");
+	if (!fp) {
+		return -1;
+	}
+	fwrite(buf, buflen, 1, fp);
+	fclose(fp);
+	return 0;
+}
 
-            static TPM2B_PUBLIC symTemplate = { 0,   // size will be computed during marshaling
-            {
-                TPM_ALG_SYMCIPHER,              // TPMI_ALG_PUBLIC      type
-                TPM_ALG_SHA256,                 // TPMI_ALG_HASH        nameAlg
-                { 0 },                          // TPMA_OBJECT  objectAttributes (set below)
-                { .t = {0, {0}} },              // TPM2B_DIGEST         authPolicy
-                { .symDetail.sym = {0} },       // TPMU_PUBLIC_PARMS    parameters (set below)
-                { .sym.b = {0} }                // TPMU_PUBLIC_ID       unique
-            } };
-            symTemplate.publicArea.objectAttributes = ToTpmaObject(Decrypt | FixedTPM | FixedParent | UserWithAuth);
-            symTemplate.publicArea.parameters.symDetail.sym.algorithm = TPM_ALG_AES;
-            symTemplate.publicArea.parameters.symDetail.sym.keyBits.sym = inner_wrap_key.t.size * 8;
-            symTemplate.publicArea.parameters.symDetail.sym.mode.sym = TPM_ALG_CFB;
-
-            memcpy(sen_create.sensitive.data.t.buffer, inner_wrap_key.t.buffer, inner_wrap_key.t.size);
-            sen_create.sensitive.data.t.size = inner_wrap_key.t.size;
-
-            memset(&sym_pub, 0, sizeof(TPM2B_PUBLIC));
-            memset(&sym_priv, 0, sizeof(TPM2B_PRIVATE));
-            if (TSS_Create(&sec_info->tpm_device, &NullPwSession, TPM_20_SRK_HANDLE, &sen_create, &symTemplate, &sym_priv, &sym_pub) != TPM_RC_SUCCESS)
-            {
-                LOG_ERROR("Failed to inject symmetric key data");
-                result = __FAILURE__;
-            }
-            else if (TPM2_Load(&sec_info->tpm_device, &NullPwSession, TPM_20_SRK_HANDLE, &id_key_priv, &id_key_Public, &load_id_key, NULL) != TPM_RC_SUCCESS)
-            {
-                LOG_ERROR("Failed Load Id key.");
-                result = __FAILURE__;
+static size_t
+size_of_file (const char *filename)
+{
+	FILE *pFile = fopen(filename, "r");
+	unsigned int lSize = 0;
+	if (pFile) {
+		fseek (pFile , 0 , SEEK_END);
+		lSize = ftell (pFile);
+		fclose(pFile);
+	}
+	return (size_t)lSize;
+}
+
+static int
+read_from_file_to_buf (const char *filename, size_t *buflen, unsigned char **buf)
+{
+	FILE *fp = fopen(filename, "rb");
+	if (!fp) {
+		return 0;
+	}
+	*buflen = size_of_file(filename);
+	*buf = (unsigned char *)malloc(sizeof(char) * (*buflen));
+	if (*buf == NULL) {
+		return -1;
+	}
+	fread(*buf, *buflen, 1, fp);
+	fclose(fp);
+	return 0;
+}
+/**
+ * Writes size bytes to a file, continuing on EINTR short writes.
+ * @param f
+ *  The file to write to.
+ * @param data
+ *  The data to write.
+ * @param size
+ *  The size, in bytes, of that data.
+ * @return
+ *  True on success, False otherwise.
+ */
+static bool writex(FILE *f, UINT8 *data, size_t size) {
+
+    size_t wrote = 0;
+    size_t index = 0;
+    do {
+        wrote = fwrite(&data[index], 1, size, f);
+        if (wrote != size) {
+            if (errno != EINTR) {
+                return false;
             }
-            else
-            {
-                // Remove old Id key
-                (void)TPM2_EvictControl(&sec_info->tpm_device, &NullPwSession, TPM_RH_OWNER, DPS_ID_KEY_HANDLE, DPS_ID_KEY_HANDLE);
-
-                if (TPM2_EvictControl(&sec_info->tpm_device, &NullPwSession, TPM_RH_OWNER, load_id_key, DPS_ID_KEY_HANDLE) != TPM_RC_SUCCESS)
-                {
-                    LOG_ERROR("Failed Load Id key.");
-                    result = __FAILURE__;
-                }
-                else if (TPM2_FlushContext(&sec_info->tpm_device, load_id_key) != TPM_RC_SUCCESS)
-                {
-                    LOG_ERROR("Failed Load Id key.");
-                    result = __FAILURE__;
-                }
-                else
-                {
-                    result = 0;
-                }
+            /* continue on EINTR */
+        }
+        size -= wrote;
+        index += wrote;
+    } while (size > 0);
+
+    return true;
+}
+
+#if 0
+/**
+ * Reads size bytes from a file, continuing on EINTR short reads.
+ * @param f
+ *  The file to read from.
+ * @param data
+ *  The data buffer to read into.
+ * @param size
+ *  The size of the buffer, which is also the amount of bytes to read.
+ * @return
+ *  True on success, False otherwise.
+ */
+static bool readx(FILE *f, UINT8 *data, size_t size) {
+
+    size_t bread = 0;
+    size_t index = 0;
+    do {
+        bread = fread(&data[index], 1, size, f);
+        if (bread != size) {
+            if (feof(f) || (errno != EINTR)) {
+                return false;
             }
+            /* continue on EINTR */
         }
-    }
-    return result;
+        size -= bread;
+        index += bread;
+    } while (size > 0);
+
+    return true;
 }
+#endif 
 
-static int initialize_tpm_device(HSM_CLIENT_INFO* tpm_info)
-{
-    int result;
-    if (TSS_CreatePwAuthSession(&NullAuth, &NullPwSession) != TPM_RC_SUCCESS)
-    {
-        LOG_ERROR("Failure calling TSS_CreatePwAuthSession");
-        result = __FAILURE__;
+static bool tpm2_util_is_big_endian(void) {
+
+    uint32_t test_word;
+    uint8_t *test_byte;
+
+    test_word = 0xFF000000;
+    test_byte = (uint8_t *) (&test_word);
+
+    return test_byte[0] == 0xFF;
+}
+
+#define STRING_BYTES_ENDIAN_CONVERT(size) \
+    UINT##size tpm2_util_endian_swap_##size(UINT##size data) { \
+    \
+        UINT##size converted; \
+        UINT8 *bytes = (UINT8 *)&data; \
+        UINT8 *tmp = (UINT8 *)&converted; \
+    \
+        size_t i; \
+        for(i=0; i < sizeof(UINT##size); i ++) { \
+            tmp[i] = bytes[sizeof(UINT##size) - i - 1]; \
+        } \
+        \
+        return converted; \
     }
-    else if (Initialize_TPM_Codec(&tpm_info->tpm_device) != TPM_RC_SUCCESS)
-    {
-        LOG_ERROR("Failure initializeing TPM Codec");
-        result = __FAILURE__;
+
+STRING_BYTES_ENDIAN_CONVERT(16)
+STRING_BYTES_ENDIAN_CONVERT(32)
+//STRING_BYTES_ENDIAN_CONVERT(64)
+
+#define BE_CONVERT(value, size) \
+    do { \
+        if (!tpm2_util_is_big_endian()) { \
+            value = tpm2_util_endian_swap_##size(value); \
+        } \
+    } while (0)
+
+#define FILE_WRITE(size) \
+    bool files_write_##size(FILE *out, UINT##size data) { \
+        BAIL_ON_NULL("FILE", out); \
+        BE_CONVERT(data, size); \
+        return writex(out, (UINT8 *)&data, sizeof(data)); \
     }
-    else if ((TSS_CreatePersistentKey(&tpm_info->tpm_device, TPM_20_EK_HANDLE, &NullPwSession, TPM_RH_ENDORSEMENT, GetEkTemplate(), &tpm_info->ek_pub) ) == 0)
-    {
-        LOG_ERROR("Failure calling creating persistent key for Endorsement key");
-        result = __FAILURE__;
+
+
+#define FILE_READ(size) \
+    bool files_read_##size(FILE *out, UINT##size *data) { \
+            BAIL_ON_NULL("FILE", out); \
+            BAIL_ON_NULL("data", data); \
+        bool res = readx(out, (UINT8 *)data, sizeof(*data)); \
+        if (res) { \
+            BE_CONVERT(*data, size); \
+        } \
+        return res; \
     }
-    else if (TSS_CreatePersistentKey(&tpm_info->tpm_device, TPM_20_SRK_HANDLE, &NullPwSession, TPM_RH_OWNER, GetSrkTemplate(), &tpm_info->srk_pub) == 0)
-    {
-        LOG_ERROR("Failure calling creating persistent key for Storage Root key");
-        result = __FAILURE__;
+
+/**
+ * This is the magic for the file header. The header is organized
+ * as a big endian U32 (BEU32) of MAGIC followed by a BEU32 of the
+ * version number. Tools can define their own, individual file
+ * formats as they make sense, but they should always have the header.
+ */
+static const UINT32 MAGIC = 0xBADCC0DE;
+
+#define BAIL_ON_NULL(param, x) \
+    do { \
+        if (!x) { \
+            LOG_ERROR(param" must be specified"); \
+            return false; \
+        } \
+    } while(0)
+
+/*
+ * all the files_read|write_bytes_16|32|64 functions
+ */
+//FILE_READ(16);
+FILE_WRITE(16)
+
+//FILE_READ(32);
+FILE_WRITE(32)
+
+//FILE_READ(64)
+//FILE_WRITE(64)
+
+#if 0
+bool files_read_bytes(FILE *out, UINT8 bytes[], size_t len) {
+
+    BAIL_ON_NULL("FILE", out);
+    BAIL_ON_NULL("bytes", bytes);
+    return readx(out, bytes, len);
+}
+#endif 
+
+static bool files_write_bytes(FILE *out, uint8_t bytes[], size_t len) {
+
+    BAIL_ON_NULL("FILE", out);
+    BAIL_ON_NULL("bytes", bytes);
+    return writex(out, bytes, len);
+}
+
+static bool files_write_header(FILE *out, UINT32 version) {
+
+    BAIL_ON_NULL("FILE", out);
+
+    bool res = files_write_32(out, MAGIC);
+    if (!res) {
+        return false;
     }
-    else
+    return files_write_32(out, version);
+}
+
+static int insert_key_in_tpm
+(
+    const unsigned char* key,
+    size_t key_len
+)
+{
+	int result = 0;
+	TPM2B_ID_OBJECT enc_key_blob;
+	TPM2B_ENCRYPTED_SECRET tpm_enc_secret;
+	TPM2B_PRIVATE id_key_dup_blob;
+	TPM2B_ENCRYPTED_SECRET encrypt_wrap_key;
+	TPM2B_PUBLIC id_key_Public;
+
+	uint8_t* curr_pos = (uint8_t*)key;
+	uint32_t act_size = (int32_t)key_len;
+	memset(&id_key_Public, 0, sizeof(TPM2B_PUBLIC));
+	id_key_Public.size = 0;
+	id_key_Public.publicArea.type = TPM_ALG_NULL;
+	DPS_UNMARSHAL(TPM2B_ID_OBJECT, &enc_key_blob);
+	DPS_UNMARSHAL(TPM2B_ENCRYPTED_SECRET, &tpm_enc_secret);
+	DPS_UNMARSHAL(TPM2B_PRIVATE, &id_key_dup_blob);
+	DPS_UNMARSHAL(TPM2B_ENCRYPTED_SECRET, &encrypt_wrap_key);
+	DPS_UNMARSHAL_FLAGGED(TPM2B_PUBLIC, &id_key_Public);
+
+	
+	uint8_t buf[4096];
+	uint8_t *pBuf = buf;
+	uint16_t buflen = 0;
+	size_t max_len = 4096;
+	DPS_MARSHAL(TPM2B_PRIVATE, &id_key_dup_blob, pBuf, max_len);
+	write_buf_to_file((char *)buf, buflen, "id_key_dup_blob.out");
+	pBuf = buf, max_len = 4096;
+	DPS_MARSHAL(TPM2B_ENCRYPTED_SECRET, &encrypt_wrap_key, pBuf, max_len);
+	write_buf_to_file((char *)buf, buflen, "encrypt_wrap_key.out");
+
+	pBuf = buf, max_len = 4096;
+	DPS_MARSHAL(TPM2B_ENCRYPTED_SECRET, &tpm_enc_secret, pBuf, max_len);
+	write_buf_to_file((char *)buf, buflen, "tpm_enc_secret.out");
+	pBuf = buf, max_len = 4096;
+	DPS_MARSHAL(TPM2B_PUBLIC, &id_key_Public, pBuf, max_len);
+	write_buf_to_file((char *)buf, buflen, "id_key_Public.out");
+
+	FILE *cred_blob_file = fopen("cred_blob.in", "w");
+	files_write_header(cred_blob_file, 1);
+	files_write_16(cred_blob_file, enc_key_blob.t.size);
+	files_write_bytes(cred_blob_file, enc_key_blob.t.credential, enc_key_blob.t.size); 
+	files_write_16(cred_blob_file, tpm_enc_secret.t.size);
+	files_write_bytes(cred_blob_file, tpm_enc_secret.t.secret, tpm_enc_secret.t.size);
+	fclose(cred_blob_file);
+
+	system("eve_run tpm2_startauthsession --policy-session -S session.ctx");
+	system("eve_run tpm2_policysecret -S session.ctx -c 0x4000000B");
+	system("eve_run tpm2_activatecredential -c 0x81000001 -C 0x81010001 -i cred_blob.in -o inner_wrap_key.out -P '\"session:session.ctx\"'");
+	system("eve_run tpm2_flushcontext session.ctx");
+
+	system("eve_run tpm2_startauthsession --policy-session -S session.ctx");
+	system("eve_run tpm2_policysecret -S session.ctx -c 0x4000000B");
+	system("eve_run tpm2_import -C 0x81000001 -k inner_wrap_key.out -u id_key_Public.out -r id_key_priv.in -i id_key_dup_blob.out -s encrypt_wrap_key.out -L dpolicy.dat");
+	system("eve_run tpm2_flushcontext session.ctx");
+	system("eve_run tpm2_load -C 0x81000001 -u id_key_Public.out -r id_key_priv.in -c id_key_context.out");
+	system("eve_run tpm2_evictcontrol -c 0x81000100");
+	system("eve_run tpm2_evictcontrol -c id_key_context.out 0x81000100");
+
+	return result;
+}
+
+static int exists(const char *fname)
+{
+    FILE *file;
+    if ((file = fopen(fname, "r")))
     {
-        result = 0;
+        fclose(file);
+        return 1;
+    }
+    return 0;
+}
+
+static int initialize_tpm_device()
+{
+    int result = 0;
+    if (!exists(EK_PUB_FILE)) {
+	    system("eve_run tpm2_createek -c 0x81010001 -G rsa -u ek.pub -f tss");
+    } 
+    if (!exists(SRK_PUB_FILE)) {
+	    system("eve_run tpm2_createprimary -C e -G rsa -g sha256 -c context.out -a \"'restricted|decrypt|fixedtpm|fixedparent|sensitivedataorigin|userwithauth'\"");
+	    system("eve_run tpm2_evictcontrol -c context.out 0x81000001");
+	    system("eve_run tpm2_readpublic -c context.out -o srk.pub -f tss");
     }
     return result;
 }
@@ -301,7 +477,7 @@ static HSM_CLIENT_HANDLE hsm_client_tpm_create()
     else
     {
         memset(result, 0, sizeof(HSM_CLIENT_INFO));
-        if (initialize_tpm_device(result) != 0)
+        if (initialize_tpm_device() != 0)
         {
             LOG_ERROR("Failure initializing tpm device.");
             free(result);
@@ -337,7 +513,7 @@ static int hsm_client_tpm_activate_identity_key
     }
     else
     {
-        if (insert_key_in_tpm((HSM_CLIENT_INFO*)handle, key, key_len))
+        if (insert_key_in_tpm(key, key_len))
         {
             LOG_ERROR("Failure inserting key into tpm");
             result = __FAILURE__;
@@ -365,34 +541,7 @@ static int hsm_client_tpm_get_endorsement_key
     }
     else
     {
-        HSM_CLIENT_INFO* hsm_client_info = (HSM_CLIENT_INFO*)handle;
-        if (hsm_client_info->ek_pub.publicArea.unique.rsa.t.size == 0)
-        {
-            LOG_ERROR("Endorsement key is invalid");
-            result = __FAILURE__;
-        }
-        else
-        {
-            unsigned char data_bytes[TPM_DATA_LENGTH];
-            unsigned char* data_pos = data_bytes;
-            uint32_t data_length = TPM2B_PUBLIC_Marshal(&hsm_client_info->ek_pub, &data_pos, NULL);
-            if (data_length > TPM_DATA_LENGTH)
-            {
-                LOG_ERROR("EK data length larger than allocated buffer %zu", (size_t)data_length);
-                result = __FAILURE__;
-            }
-            else if ((*key = (unsigned char*)malloc(data_length)) == NULL)
-            {
-                LOG_ERROR("Failure creating buffer handle");
-                result = __FAILURE__;
-            }
-            else
-            {
-                memcpy(*key, data_bytes, data_length);
-                *key_len = (size_t)data_length;
-                result = 0;
-            }
-        }
+	result = read_from_file_to_buf(EK_PUB_FILE, key_len, key);
     }
     return result;
 }
@@ -412,35 +561,7 @@ static int hsm_client_tpm_get_storage_key
     }
     else
     {
-        HSM_CLIENT_INFO* hsm_client_info = (HSM_CLIENT_INFO*)handle;
-        if (hsm_client_info->srk_pub.publicArea.unique.rsa.t.size == 0)
-        {
-            LOG_ERROR("storage root key is invalid");
-            result = __FAILURE__;
-        }
-        else
-        {
-            unsigned char data_bytes[TPM_DATA_LENGTH];
-            unsigned char* data_pos = data_bytes;
-            uint32_t data_length = TPM2B_PUBLIC_Marshal(&hsm_client_info->srk_pub, &data_pos, NULL);
-
-            if (data_length > TPM_DATA_LENGTH)
-            {
-                LOG_ERROR("SRK data length larger than allocated buffer %zu", (size_t)data_length);
-                result = __FAILURE__;
-            }
-            else if ((*key = (unsigned char*)malloc(data_length)) == NULL)
-            {
-                LOG_ERROR("Failure creating buffer handle");
-                result = __FAILURE__;
-            }
-            else
-            {
-                memcpy(*key, data_bytes, data_length);
-                *key_len = (size_t)data_length;
-                result = 0;
-            }
-        }
+	result = read_from_file_to_buf(SRK_PUB_FILE, key_len, key);
     }
     return result;
 }
@@ -454,7 +575,7 @@ static int hsm_client_tpm_sign_data
     size_t* digest_size
 )
 {
-    int result;
+    int result = 0;
 
     if (handle == NULL || data_to_be_signed == NULL || data_to_be_signed_size == 0 ||
                     digest == NULL || digest_size == NULL)
@@ -463,35 +584,10 @@ static int hsm_client_tpm_sign_data
             handle, data_to_be_signed, data_to_be_signed_size, digest, digest_size);
         result = __FAILURE__;
     }
-    else
-    {
-        BYTE data_signature[TPM_DATA_LENGTH];
-        BYTE* data_copy = (unsigned char*)data_to_be_signed;
-        HSM_CLIENT_INFO* hsm_client_info = (HSM_CLIENT_INFO*)handle;
-
-        uint32_t sign_len = SignData(&hsm_client_info->tpm_device,
-                        &NullPwSession, data_copy, (UINT32)data_to_be_signed_size,
-                        data_signature, sizeof(data_signature) );
-        if (sign_len == 0)
-        {
-            LOG_ERROR("Failure signing data from hash");
-            result = __FAILURE__;
-        }
-        else
-        {
-            if ((*digest = (unsigned char*)malloc(sign_len)) == NULL)
-            {
-                LOG_ERROR("Failure creating buffer handle");
-                result = __FAILURE__;
-            }
-            else
-            {
-                memcpy(*digest, data_signature, sign_len);
-                *digest_size = (size_t)sign_len;
-                result = 0;
-            }
-        }
-    }
+    write_buf_to_file((char *)data_to_be_signed, data_to_be_signed_size, "tok.dat");
+    system("eve_run cp -f tok.dat token.dat");
+    system("eve_run tpm2_hmac -c 0x81000100 -g sha256 -o hmac.out token.dat");
+    read_from_file_to_buf("hmac.out", digest_size, digest); 
     return result;
 }
 
